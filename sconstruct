# NVDA add-on template SCONSTRUCT file
# Copyright (C) 2012-2025 Rui Batista, Noelia Martinez, Joseph Lee
# This file is covered by the GNU General Public License.
# See the file COPYING.txt for more details.

import codecs
import gettext
import os
import os.path
import sys
from pathlib import Path
from collections.abc import Iterable
from typing import Final, Mapping

# While names imported below are available by default in every SConscript
# Linters aren't aware about them.
# To avoid PyRight `reportUndefinedVariable` errors about them they are imported explicitly.
# When using other  Scons functions please add them to the line below.
from SCons.Script import EnsurePythonVersion, Variables, BoolVariable, Environment, Builder, Copy

# Imports for type hints
from SCons.Node import FS
from SCons.Action import CommandAction

# Add-on localization exchange facility and the template requires Python 3.10.
# For best practice, use Python 3.11 or later to align with NVDA development.
EnsurePythonVersion(3, 10)

# Bytecode should not be written for build vars module to keep the repository root folder clean.
sys.dont_write_bytecode = True

import buildVars  # NOQA: E402


def validateVersionNumber(key: str, val: str, _):
	# Used to make sure version major.minor.patch are integers to comply with NV Access add-on store.
	# Ignore all this if version number is not specified.
	if val == "0.0.0":
		return
	versionNumber = val.split(".")
	if len(versionNumber) < 3:
		raise ValueError(f"{key} must have three parts (major.minor.patch)")
	if not all([part.isnumeric() for part in versionNumber]):
		raise ValueError(f"{key} (major.minor.patch) must be integers")


def manifestTool(env: Environment):
	action = env.Action(
		lambda target, source, env: generateManifest(source[0].abspath, target[0].abspath) and None,
		lambda target, source, env: f"Generating manifest {target[0]}",
	)
	env["BUILDERS"]["NVDAManifest"] = Builder(
		action=action,
		suffix=".ini",
		src_siffix=".ini.tpl"
	)


def translatedManifestGenerator(target: list[FS.Entry], source: list[FS.Entry], env: Environment, for_signature: bool) -> CommandAction:
	dir = Path(str(source[0])).absolute().parents[1]
	lang = dir.name
	action = env.Action(
		lambda target, source, env: generateTranslatedManifest(source[1].abspath, lang, target[0].abspath)
		and None,
		lambda target, source, env: f"Generating translated manifest {target[0]}",
	)
	return action


def format_nested_section(
	section_name: str,
	data: Mapping[str, Mapping[str, str]]
) -> str:
	lines = [f"\n[{section_name}]"]
	for item_name, inner_dict in data.items():
		lines.append(f"[[{item_name}]]")
		for key, val in inner_dict.items():
			lines.append(f"{key} = {val}")
	return "\n".join(lines) + "\n"


def generateManifest(source: str, dest: str):
	# Prepare the root manifest section
	addon_info = buildVars.addon_info
	with codecs.open(source, "r", "utf-8") as f:
		manifest_template = f.read()
	manifest = manifest_template.format(**addon_info)
	# Add additional manifest sections such as custom braile tables
	# Custom braille translation tables
	if hasattr(buildVars, "brailleTables"):
		manifest += format_nested_section("brailleTables", buildVars.brailleTables)

	# Custom speech symbol dictionaries
	if hasattr(buildVars, "symbolDictionaries"):
		manifest += format_nested_section("symbolDictionaries", buildVars.symbolDictionaries)

	with codecs.open(dest, "w", "utf-8") as f:
		f.write(manifest)


def generateTranslatedManifest(source: str, language: str, dest: str):
	_ = gettext.translation("nvda", localedir=localeDir, languages=[language]).gettext
	vars: dict[str, str] = {}
	for var in ("addon_summary", "addon_description"):
		vars[var] = _(buildVars.addon_info[var])
	with codecs.open(source, "r", "utf-8") as f:
		manifest_template = f.read()
	manifest = manifest_template.format(**vars)

	def _format_section_only_with_displayName(section_name: str, data: Mapping[str, Mapping[str, str]]) -> str:
		lines = [f"\n[{section_name}]"]
		for item, inner_dict in data.items():
			lines.append(f"[[{item}]]")
			# Fetch display name only.
			lines.append(f"displayName = {_(inner_dict['displayName'])}")
		return "\n".join(lines) + "\n"

	# Add additional manifest sections such as custom braile tables
	# Custom braille translation tables
	if tables := getattr(buildVars, "brailleTables", None):
		manifest += _format_section_only_with_displayName("brailleTables", tables)

	# Custom speech symbol dictionaries
	if dicts := getattr(buildVars, "symbolDictionaries", None):
		manifest += _format_section_only_with_displayName("symbolDictionaries", dicts)

	with codecs.open(dest, "w", "utf-8") as f:
		f.write(manifest)


def expandGlobs(patterns: Iterable[str], rootdir: Path = Path(".")) -> list[FS.Entry]:
	return [env.Entry(e) for pattern in patterns for e in rootdir.glob(pattern.lstrip('/'))]


addonDir: Final = Path("addon/")
localeDir: Final = addonDir / "locale"
docsDir: Final = addonDir / "doc"


vars = Variables()
vars.Add("version", "The version of this build", buildVars.addon_info["addon_version"])
vars.Add("versionNumber", "Version number of the form major.minor.patch", "0.0.0", validateVersionNumber)
vars.Add(BoolVariable("dev", "Whether this is a daily development version", False))
vars.Add("channel", "Update channel for this build", buildVars.addon_info["addon_updateChannel"])

env = Environment(variables=vars, ENV=os.environ, tools=["gettexttool", "mdTool", "NVDATool", manifestTool])
env.Append(**buildVars.addon_info)

if env["dev"]:
	from datetime import date

	versionTimestamp = date.today().strftime('%Y%m%d')
	version = f"{versionTimestamp}.0.0"
	env["addon_version"] = version
	env["versionNumber"] = version
	env["channel"] = "dev"
elif env["version"] is not None:
	env["addon_version"] = env["version"]
if "channel" in env and env["channel"] is not None:
	env["addon_updateChannel"] = env["channel"]

buildVars.addon_info["addon_version"] = env["addon_version"]
buildVars.addon_info["addon_updateChannel"] = env["addon_updateChannel"]


env["BUILDERS"]["NVDATranslatedManifest"] = Builder(generator=translatedManifestGenerator)


addonFile = env.File("${addon_name}-${addon_version}.nvda-addon")
addon = env.NVDAAddon(addonFile, env.Dir(addonDir), excludePatterns=buildVars.excludedFiles)

langDirs: list[FS.Dir] = [d for d in env.Glob(localeDir/"*/")]

# Allow all NVDA's gettext po files to be compiled in source/locale, and manifest files to be generated
moByLang: dict[FS.Dir, FS.File] = {}
for dir in langDirs:
	poFile = dir.File(os.path.join("LC_MESSAGES", "nvda.po"))
	moFile = env.gettextMoFile(poFile)
	moByLang[dir] = moFile
	env.Depends(moFile, poFile)
	translatedManifest = env.NVDATranslatedManifest(
		dir.File("manifest.ini"), [moFile, "manifest-translated.ini.tpl"]
	)
	env.Depends(translatedManifest, ["buildVars.py"])
	env.Depends(addon, [translatedManifest, moFile])

pythonFiles = expandGlobs(buildVars.pythonSources)
for file in pythonFiles:
	env.Depends(addon, file)

# Convert markdown files to html
# We need at least doc in English and should enable the Help button for the add-on in Add-ons Manager
if (cssFile := Path("style.css")).is_file():
	cssPath = docsDir / cssFile
	cssTarget = env.Command(str(cssPath), str(cssFile), Copy("$TARGET", "$SOURCE"))
	env.Depends(addon, cssTarget)

if (readmeFile := Path("readme.md")).is_file():
	readmePath = docsDir / buildVars.baseLanguage / readmeFile
	readmeTarget = env.Command(str(readmePath), str(readmeFile), Copy("$TARGET", "$SOURCE"))
	env.Depends(addon, readmeTarget)

for mdFile in env.Glob(docsDir/"*/*.md"):
	# the title of the html file is translated based on the contents of something in the moFile for a language.
	# Thus, we find the moFile for this language and depend on it if it exists.
	lang = Path(str(mdFile)).absolute().parent.name
	moFile = moByLang.get(lang)
	htmlFile = env.md2html(mdFile, localeDir=localeDir, localeFileName="nvda", mdExtensions=buildVars.markdownExtensions)
	env.Depends(htmlFile, mdFile)
	if moFile:
		env.Depends(htmlFile, moFile)
	env.Depends(addon, htmlFile)

# Pot target
i18nFiles = expandGlobs(buildVars.i18nSources)
gettextvars: dict[str, str] = {
	"gettext_package_bugs_address": "nvda-translations@groups.io",
	"gettext_package_name": buildVars.addon_info["addon_name"],
	"gettext_package_version": buildVars.addon_info["addon_version"],
}

pot = env.gettextPotFile("${addon_name}.pot", i18nFiles, **gettextvars)
env.Alias("pot", pot)
env.Depends(pot, i18nFiles)
mergePot = env.gettextMergePotFile("${addon_name}-merge.pot", i18nFiles, **gettextvars)
env.Alias("mergePot", mergePot)
env.Depends(mergePot, i18nFiles)

# Generate Manifest path
manifest = env.NVDAManifest(env.File(addonDir/"manifest.ini"), "manifest.ini.tpl")
# Ensure manifest is rebuilt if buildVars is updated.
env.Depends(manifest, "buildVars.py")

env.Depends(addon, manifest)
env.Default(addon)
env.Clean(addon, [".sconsign.dblite", "addon/doc/" + buildVars.baseLanguage + "/"])
